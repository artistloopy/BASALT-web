---
import PageLayout from '~/layouts/PageLayout.astro';
import WidgetWrapper from '~/components/ui/WidgetWrapper.astro';

const metadata = {
  title: 'Community Forum',
  description: 'Join the BASALT community ‚Äî ask questions, share tips, and collaborate.',
};
---

<PageLayout {metadata}>
  <!-- Supabase configuration warning (hidden by default) -->
  <div id="supabase-warning" class="hidden max-w-7xl mx-auto px-6 sm:px-8 lg:px-12 pt-4 md:pt-6 lg:pt-8">
    <div class="bg-yellow-50 border-l-4 border-yellow-400 p-4 rounded">
      <p class="text-sm text-yellow-800" id="supabase-warning-text">Supabase not configured ‚Äî some features (register/login/posting) require PUBLIC_SUPABASE_URL and PUBLIC_SUPABASE_ANON_KEY to be set in environment variables.</p>
    </div>
  </div>
  <!-- Welcome header (moved into main section below to match Resource Center layout) -->

  <!-- Auth is now exposed in the site header (top-right). -->

  <section class="max-w-7xl mx-auto px-6 sm:px-8 lg:px-12 pt-4 md:pt-6 lg:pt-8">
    <div class="mb-6">
      <h1 class="text-4xl font-bold">Welcome to BASALT communityÔºÅ</h1>
      <p class="text-muted mt-2">Hey, it's great to meet you here!</p>
    </div>
    <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
  <!-- Topics list -->
  <aside class="lg:col-span-1 -mt-6 md:-mt-8 lg:-mt-10">
        <WidgetWrapper classes={{ container: 'p-0' }}>
          <div class="bg-white dark:bg-slate-800 rounded shadow-sm overflow-hidden">
            <div class="px-4 py-3 border-b">
              <h4 class="font-semibold">Topics</h4>
            </div>
            <ul class="divide-y">
              <li class="">
                <a href="#" class="block px-4 py-3 hover:bg-[#006994] hover:text-white transition">Performance tips</a>
              </li>
              <li>
                <a href="#" class="block px-4 py-3 hover:bg-[#006994] hover:text-white transition">Binning strategies</a>
              </li>
              <li>
                <a href="#" class="block px-4 py-3 hover:bg-[#006994] hover:text-white transition">Bioinformatics</a>
              </li>
              <li>
                <a href="#" class="block px-4 py-3 hover:bg-[#006994] hover:text-white transition">Technical issues</a>
              </li>
              <li>
                <a href="#" class="block px-4 py-3 hover:bg-[#006994] hover:text-white transition">Feedback and Improvement</a>
              </li>
            </ul>
          </div>
        </WidgetWrapper>
      </aside>

      <!-- Main content / placeholder for thread list -->
      <div class="lg:col-span-2">
        <WidgetWrapper>
          <div class="bg-white dark:bg-slate-800 rounded shadow-sm p-6">
            <!-- Auth moved to header: register/login available in top-right "Account" panel -->
            <div class="flex items-center justify-between mb-4">
              <div class="flex items-center space-x-3" id="community-tabs">
                <button type="button" data-mode="latest" class="tab-btn px-3 py-1 rounded bg-[#006994] text-white text-sm font-medium">Latest</button>
                <button type="button" data-mode="most-liked" class="tab-btn px-3 py-1 rounded text-sm font-medium">Most liked</button>
                <button type="button" data-mode="my-posts" class="tab-btn px-3 py-1 rounded text-sm font-medium">My posts</button>
                <button type="button" data-mode="my-liked" class="tab-btn px-3 py-1 rounded text-sm font-medium">My liked</button>
              </div>
              <button type="button" id="open-new-topic" class="text-sm font-medium text-[#006994] hover:underline">New topic</button>
            </div>

            <ul id="thread-list" class="space-y-4"></ul>

            <!-- New Topic Modal (moved to document body for reliable fixed positioning) -->
          </div>
        </WidgetWrapper>
      </div>
    </div>
  </section>
</PageLayout>

<!-- New Topic Modal (moved to document root so fixed positioning works reliably) -->
<div id="new-topic-modal" class="hidden fixed inset-0 z-50">
  <div class="flex items-start sm:items-center justify-center min-h-screen p-4">
    <div class="absolute inset-0 bg-black/50" aria-hidden="true"></div>
    <div class="relative bg-white dark:bg-slate-800 rounded shadow-lg w-full max-w-2xl p-6 z-10 max-h-[90vh] overflow-auto">
      <h4 class="text-lg font-semibold mb-2">Create new topic</h4>
      <form id="new-topic-form" class="space-y-3">
        <input id="new-topic-title" required class="w-full rounded border px-3 py-2" placeholder="Title" />
        <textarea id="new-topic-content" required class="w-full rounded border px-3 py-2" rows="6" placeholder="Write your question or topic details"></textarea>
        <div class="flex justify-end gap-2">
          <button type="button" id="cancel-new-topic" class="px-3 py-1 rounded border">Cancel</button>
          <button type="submit" class="px-4 py-2 rounded bg-[#006994] text-white">Post</button>
        </div>
      </form>
    </div>
  </div>
</div>

<!-- Supabase powered client-script: handles auth, loading posts and creating posts -->
<!-- Quick inline test to verify scripts run in the browser -->
<script>
  try { console.log('[community] inline test'); } catch (e) { console.error('[community] inline test error', e); }
</script>

<script type="module">
  // dynamically import the Supabase client for the browser at runtime using an absolute path
  let supabase = null;
  try {
    const mod = await import('/src/lib/supabase.ts');
    supabase = mod?.supabase || mod?.default || null;
  } catch (e) {
    console.debug('[community] could not import supabase client', e);
  }

  const $ = (id) => document.getElementById(id);

  console.log('[community] script loaded', { hasSupabase: !!supabase });

  // cached current user to avoid round-trip auth calls on every click
  let CURRENT_USER = null;

  // helper to open the header auth panel reliably (avoid relying on element click which may not have listeners attached yet)
  function openAuthPanel() {
    try {
      const panel = document.getElementById('auth-panel');
      if (panel) {
        panel.classList.remove('hidden');
        const prov = document.getElementById('header-github-btn');
        try { prov?.focus(); } catch { /* noop */ }
        return true;
      }
    } catch { /* noop */ }
    try { const btn = document.getElementById('open-login-panel'); if (btn) { btn.click(); return true; } } catch { /* noop */ }
    return false;
  }

  // escape helper to avoid XSS when inserting HTML
  function escapeHtml(s) {
    return String(s || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  }

  // simple toast helper (in-page notifications)
  function ensureToastContainer() {
    let c = document.getElementById('toast-container');
    if (!c) {
      c = document.createElement('div');
      c.id = 'toast-container';
      c.style.position = 'fixed';
      c.style.right = '1rem';
      c.style.top = '1rem';
      c.style.zIndex = '99999';
      c.style.display = 'flex';
      c.style.flexDirection = 'column';
      c.style.gap = '0.5rem';
      document.body.appendChild(c);
    }
    return c;
  }

  function showToast(message, type = 'info', timeout = 4000) {
    try {
      const container = ensureToastContainer();
      const el = document.createElement('div');
      el.setAttribute('role', 'status');
      el.style.minWidth = '180px';
      el.style.maxWidth = '380px';
      el.style.padding = '0.6rem 0.8rem';
      el.style.borderRadius = '8px';
      el.style.boxShadow = '0 6px 18px rgba(0,0,0,0.08)';
      el.style.color = 'white';
      el.style.fontSize = '0.95rem';
      el.style.lineHeight = '1.2';
      el.style.opacity = '0';
      el.style.transition = 'opacity 220ms ease, transform 220ms ease';
      el.style.transform = 'translateY(-6px)';
      if (type === 'error') el.style.background = '#ef4444';
      else if (type === 'success') el.style.background = '#10b981';
      else if (type === 'warn') el.style.background = '#f59e0b';
      else el.style.background = '#374151';
      el.textContent = message;
      container.appendChild(el);
      // animate in
      requestAnimationFrame(() => { el.style.opacity = '1'; el.style.transform = 'translateY(0)'; });
      const to = setTimeout(() => {
        // animate out
        el.style.opacity = '0'; el.style.transform = 'translateY(-6px)';
  setTimeout(() => { try { container.removeChild(el); } catch { void 0; } }, 240);
      }, timeout);
  el.addEventListener('click', () => { clearTimeout(to); el.style.opacity = '0'; setTimeout(() => { try { container.removeChild(el); } catch { void 0; } }, 200); });
      return el;
  } catch {
      try { alert(message); } catch { console.log(message); }
    }
  }

  // Render current auth status into header/sidebar if present
  async function renderUser(user) {
    if ($('auth-status')) {
      if (user) {
        const display = user.user_metadata?.name || user.email?.split('@')[0] || 'User';
  $('auth-status').innerHTML = `Hi, <strong class="break-words" title="${escapeHtml(user.email || '')}">${escapeHtml(display)}</strong> <button id="logoutBtn" class="ml-3 text-sm text-[#006994] hover:underline">Logout</button>`;
        $('logoutBtn')?.addEventListener('click', async (e) => {
          e.preventDefault();
          await supabase.auth.signOut();
          await initAuth();
        });
      } else {
        $('auth-status').textContent = 'Not signed in';
      }
    }

    if ($('auth-status-header')) {
      if (user) {
        const display = user.user_metadata?.name || user.email?.split('@')[0] || '';
  $('auth-status-header').textContent = `Hi, ${display}`;
  $('auth-status-header').setAttribute('title', user.email || '');
  try { $('auth-status-header').style.whiteSpace = 'normal'; } catch (e) { void e; }
        // toggle header buttons if exist
        $('open-register-panel')?.classList.add('hidden');
        $('open-login-panel')?.classList.add('hidden');
        $('close-auth-panel')?.classList.remove('hidden');
        const headerLogout = $('header-logout');
        if (headerLogout) {
          headerLogout.classList.remove('hidden');
          headerLogout.onclick = async (ev) => { ev.preventDefault(); await supabase.auth.signOut(); await initAuth(); };
        }
      } else {
        $('auth-status-header').textContent = '';
        $('open-register-panel')?.classList.remove('hidden');
        $('open-login-panel')?.classList.remove('hidden');
        $('close-auth-panel')?.classList.add('hidden');
  if ($('header-logout')) $('header-logout').classList.add('hidden');
      }
    }
    // update cached user for fast access in event handlers
    try { CURRENT_USER = user; } catch { CURRENT_USER = user; }
  }

  async function initAuth() {
    const { data } = await supabase.auth.getUser();
    const user = data?.user ?? null;
    await renderUser(user);

    // listen for auth changes
    supabase.auth.onAuthStateChange(async (_event, session) => {
      const u = session?.user ?? null;
      await renderUser(u);
    });

    // use the top-level openAuthPanel implementation instead of redefining it here

    // registration-related modals and resend logic removed
  }

  // pending posts stored locally until server confirms persistence
  function getPendingPosts() {
    try { return JSON.parse(localStorage.getItem('bb_pending_posts') || '[]'); } catch { return []; }
  }
  function savePendingPosts(arr) { try { localStorage.setItem('bb_pending_posts', JSON.stringify(arr)); } catch (e) { void e; } }
  function addPendingPost(post) {
    const arr = getPendingPosts();
    arr.unshift(post);
    savePendingPosts(arr);
  }
  function removePendingMatching(serverRow) {
    try {
      const arr = getPendingPosts();
      const left = arr.filter(p => {
        // match by id (if temp id used) or by title+content+approx timestamp
        if (p.id && serverRow.id && String(p.id) === String(serverRow.id)) return false;
        if (p.title === serverRow.title && (p.content || '').slice(0,200) === (serverRow.content||'').slice(0,200)) return false;
        return true;
      });
      savePendingPosts(left);
  } catch (e) { void e; }
  }

  // registration handler removed

  async function handleHeaderLogin(e) {
    e.preventDefault();
    const email = $('h-login-email')?.value?.trim();
    const pwd = $('h-login-password')?.value || '';
  if (!email || !pwd) return showToast('Please enter email and password', 'error');
  const { error } = await supabase.auth.signInWithPassword({ email, password: pwd });
  if (error) return showToast(error.message || 'Login failed', 'error');
  showToast('Login successful', 'success');
    $('header-loginForm')?.classList.add('hidden');
  }

  // Fallback event delegation for clicks and form submits in case direct listeners fail
  document.body.addEventListener('click', async (ev) => {
    try {
      const t = ev.target;
      if (!t) return;
      // open auth panel
      // open-register-panel removed (registration disabled)
      if (t.id === 'open-login-panel' || (t.closest && t.closest('#open-login-panel'))) {
        ev.preventDefault();
        // open auth panel reliably
        openAuthPanel();
        return;
      }
  // New topic button (delegated) - ensures clicks work even if direct listener wasn't bound
      if (t.id === 'open-new-topic' || t.closest && t.closest('#open-new-topic')) {
        ev.preventDefault();
        // prefer cached CURRENT_USER to avoid an extra auth call
        if (!CURRENT_USER) {
          // try quick check with supabase to confirm
          try {
            const { data } = await supabase.auth.getUser();
            CURRENT_USER = data?.user ?? null;
          } catch { /* noop */ }
        }
        // Fallback: if CURRENT_USER isn't set but the header shows a logged-in user, treat as logged in
        try {
          const headerStatus = document.getElementById('auth-status-header');
          if (!CURRENT_USER && headerStatus && (headerStatus.textContent || '').trim()) {
            CURRENT_USER = { __inferred_from_dom: true };
          }
        } catch { /* noop */ }
        // Always open the new-topic modal; if the user is not logged in show a toast prompting login
        if (!CURRENT_USER) {
          showToast('Please log in to post (you can still view this dialog)', 'warn');
        }
        $('new-topic-modal')?.classList.remove('hidden');
        $('new-topic-title')?.focus();
        return;
      }
      // Cancel new topic (delegated) - catches clicks on the cancel button even if direct listener missing
      if (t.id === 'cancel-new-topic' || (t.closest && t.closest('#cancel-new-topic'))) {
  try { ev.preventDefault(); document.getElementById('new-topic-modal')?.classList.add('hidden'); } catch (e) { void e; }
        return;
      }
  } catch (err) {
      console.error('[community] click delegation error', err);
    }
  });

  // Comments: server-backed (via /api/comments) with client-side pager state
  // comments pager state (kept locally in function scope when needed)
  const COMMENTS_PAGE_LIMIT = 5;

  async function fetchComments(postId, page = 1, limit = COMMENTS_PAGE_LIMIT) {
    try {
      const resp = await fetch(`/api/comments?postId=${encodeURIComponent(postId)}&page=${page}&limit=${limit}`);
      if (!resp.ok) return { data: [], total: 0, page, limit };
      const json = await resp.json();
      return { data: json.data || [], total: json.total || 0, page: json.page || page, limit: json.limit || limit };
  } catch (e) {
      console.debug('fetchComments failed', e);
      return { data: [], total: 0, page, limit };
    }
  }

  async function postCommentToServer(postId, content, parentId = null) {
    try {
      const { data: _sess } = await supabase.auth.getSession();
      const token = _sess?.session?.access_token || null;
      if (!token) return { error: 'Not authenticated' };
  const body = { post_id: postId, content };
  // include parent_id when replying
  if (parentId) body.parent_id = parentId;
      const resp = await fetch('/api/comments', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` },
        body: JSON.stringify(body),
      });
      if (!resp.ok) return { error: 'Failed to post' };
      const json = await resp.json();
      return { data: json.data || [] };
    } catch (e) {
      console.error('postCommentToServer error', e);
      return { error: String(e) };
    }
  }

  async function renderCommentsForPost(postId, page = 1) {
  // (pager state is handled locally; no top-level variables required)
    const list = document.getElementById('pd-comments-list');
  // const countEl = document.getElementById('pd-comments'); // not used here (pd-comments-count updated below)
  const pagerLeft = document.getElementById('pd-comments-left');
  const pagerRight = document.getElementById('pd-comments-right');
  const pageDisplay = document.getElementById('pd-comments-page-display');
    if (!list) return;
    list.innerHTML = '<li class="text-sm text-muted">Loading...</li>';
    const res = await fetchComments(postId, page, COMMENTS_PAGE_LIMIT);
    list.innerHTML = '';
  // read navigation username (if present) to display instead of generic 'Anonymous' when comments lack author_display
    const navStatusEl = document.getElementById('auth-status-header');
    let navName = navStatusEl ? (navStatusEl.textContent || '').trim() : null;
    // header often uses "Hi, NAME" ‚Äî strip polite prefix if present
    if (navName && navName.toLowerCase().startsWith('hi,')) {
      navName = navName.substring(3).trim();
    }
    // Build a tree view: top-level comments first, then replies indented
    const comments = Array.isArray(res.data) ? res.data.slice() : [];
    // build a quick id map for the current page slice so we can detect orphaned replies
    const idMap = {};
    for (const c of comments) {
      if (c && c.id != null) idMap[String(c.id)] = true;
    }

    // replies map: parent_id -> [comments]
    const repliesMap = {};
    for (const c of comments) {
      if (c.parent_id) {
        const pid = String(c.parent_id);
        repliesMap[pid] = repliesMap[pid] || [];
        repliesMap[pid].push(c);
      }
    }

    // Top-level comments for this page are those without a parent OR whose parent is not present
    // in the current page slice (render orphaned replies as standalone items so the visible
    // count matches the server-reported total for this page slice).
    const topLevel = comments.filter(c => !c.parent_id || !idMap[String(c.parent_id)]);

    function createCommentLi(c, indent = 0) {
      const li = document.createElement('li');
      li.className = 'rounded border p-2';
      if (indent) li.className += ' ml-6 border-l pl-3 text-sm';

      const rawAuthor = (c.author_display || '') + '';
      const low = rawAuthor.trim().toLowerCase();
  const isPlaceholder = !rawAuthor.trim() || low === 'anonymous' || low === 'anon';
  const author = escapeHtml(isPlaceholder ? (navName || 'Anonymous') : rawAuthor);
      const content = escapeHtml(c.content || '');
      const time = c.created_at ? new Date(c.created_at).toLocaleString() : '';

      // basic comment HTML with reply button
      li.innerHTML = `<div class="flex justify-between items-start"><div><div class="text-sm font-medium">${author} <span class="text-xs text-muted ml-2">${time}</span></div><div class="mt-1 text-sm">${content}</div></div><div class="ml-3 flex flex-col items-end"><button class="reply-btn text-sm text-[#006994] hover:underline" data-id="${c.id}">Reply</button></div></div>`;

      // attach reply handler
      const replyBtn = li.querySelector('.reply-btn');
      if (replyBtn) {
        replyBtn.addEventListener('click', (ev) => {
          ev.preventDefault();
          toggleReplyForm(li, c.id);
        });
      }

      list.appendChild(li);
      // append any replies
      const kids = repliesMap[String(c.id)] || [];
      if (kids.length) {
        kids.sort((a,b)=> new Date(a.created_at) - new Date(b.created_at)).forEach(k => createCommentLi(k, indent + 1));
      }
    }

    // toggle an inline reply form under a comment li
  async function toggleReplyForm(containerLi, parentId) {
      try {
        // remove existing form if present
        const existing = containerLi.querySelector('.reply-form');
        if (existing) { existing.remove(); return; }

        // Check if user is logged in. If not, show a small CTA to login instead of the reply textarea.
        let isUser = false;
        try {
          const { data: _u } = await supabase.auth.getUser();
          isUser = !!(_u?.user);
        } catch { /* noop */ }

        const formWrap = document.createElement('div');
        formWrap.className = 'reply-form mt-2';

        if (!isUser) {
          // unauthenticated -> show login CTA
          formWrap.innerHTML = `<div class="p-2 rounded border text-sm text-muted">Please log in to comment <button class="reply-login ml-2 px-2 py-1 rounded bg-[#006994] text-white text-sm">Login</button></div>`;
          const loginBtn = formWrap.querySelector('.reply-login');
          if (loginBtn) loginBtn.addEventListener('click', (e) => { e.preventDefault(); openAuthPanel(); });
          containerLi.appendChild(formWrap);
          return;
        }

        // authenticated -> render reply form
        formWrap.innerHTML = `<textarea class="reply-input w-full rounded border px-2 py-1 text-sm" rows="3" placeholder="Write a reply..."></textarea><div class="flex justify-end mt-1"><button class="reply-cancel px-2 py-1 mr-2 border rounded text-sm">Cancel</button><button class="reply-submit px-3 py-1 rounded bg-[#006994] text-white text-sm">Reply</button></div>`;
        const cancel = formWrap.querySelector('.reply-cancel');
        const submit = formWrap.querySelector('.reply-submit');
        const textarea = formWrap.querySelector('.reply-input');
        if (cancel) cancel.addEventListener('click', (e) => { e.preventDefault(); formWrap.remove(); });
        if (submit) submit.addEventListener('click', async (e) => {
          try {
            e.preventDefault();
            const text = (textarea && textarea.value) ? textarea.value.trim() : '';
            if (!text) return showToast('Reply cannot be empty', 'error');
            // post reply (include parentId)
            const res = await postCommentToServer(postId, text, parentId);
            if (res && res.error) { showToast('Reply failed: ' + (res.error || ''), 'error'); return; }
            // refresh comments to show reply
            await renderCommentsForPost(postId, 1);
          } catch (err) { console.error('reply submit error', err); showToast('Reply failed', 'error'); }
        });

        containerLi.appendChild(formWrap);
        textarea?.focus();
  } catch (err) { void err; }
    }

      // render
      topLevel.sort((a,b)=> new Date(b.created_at) - new Date(a.created_at)).forEach(c => createCommentLi(c, 0));

      // Update displayed comment count: show "visible/total" so users understand paging
      try {
        const cc = document.getElementById('pd-comments-count');
        if (cc) {
          // number of rendered list items
          const rendered = Array.from(list.children).length;
          const total = Number(res.total || rendered || 0);
          if (rendered === total) cc.textContent = String(total);
          else cc.textContent = `${rendered}/${total}`;
        }
      } catch { /* noop */ }
  // Also update the comment count visible in the thread list for this post so both views match
  try {
    const threadLi = document.querySelector(`.thread-item[data-id="${postId}"]`);
    if (threadLi) {
      const fonts = threadLi.querySelectorAll('.font-medium');
      if (fonts && fonts.length) {
        const last = fonts[fonts.length - 1];
        last.textContent = String(res.total || 0);
      }
      threadLi.setAttribute('data-comments', String(res.total || 0));
    }
  } catch (e) { void e; }
    // pager enable/disable
    const lastPage = Math.max(1, Math.ceil((res.total || 0) / (res.limit || COMMENTS_PAGE_LIMIT)));
    if (pageDisplay) pageDisplay.textContent = `${res.page || 1}/${lastPage}`;
    if (pagerLeft) pagerLeft.disabled = (res.page || 1) <= 1;
    if (pagerRight) pagerRight.disabled = (res.page || 1) >= lastPage;

    // bind pager clicks
  if (pagerLeft) pagerLeft.onclick = (e) => { e.preventDefault(); if ((res.page || 1) > 1) renderCommentsForPost(postId, (res.page || 1) - 1); };
  if (pagerRight) pagerRight.onclick = (e) => { e.preventDefault(); if ((res.page || 1) < lastPage) renderCommentsForPost(postId, (res.page || 1) + 1); };
  }

  document.body.addEventListener('submit', (ev) => {
    try {
      const form = ev.target;
      if (!form || !form.id) return;
  // header-registerForm handler removed (registration disabled)
      if (form.id === 'header-loginForm') return handleHeaderLogin(ev);
    } catch (err) {
      console.error('[community] submit delegation error', err);
    }
  });

  // Load posts from Supabase
  async function loadPosts() {
    // Prefer server-side API which can fallback to a local file if Supabase table is missing
    try {
      const resp = await fetch('/api/posts');
      if (resp.ok) {
        const json = await resp.json();
        let serverData = json?.data || [];
        // Merge pending local posts so they remain visible until server confirms them
        try {
          const pending = getPendingPosts();
          // filter out any pending that already exist on server (match by title+content)
          const merged = [];
          // prepend pending posts that are not yet on server
          for (const p of pending) {
            const exists = serverData.some(s => (s.id && p.id && String(s.id) === String(p.id)) || (s.title === p.title && (s.content||'').slice(0,200) === (p.content||'').slice(0,200)));
            if (!exists) merged.push(p);
          }
          serverData = merged.concat(serverData);
          // attempt to clear any pending that are now on server
          for (const s of json?.data || []) removePendingMatching(s);
  } catch (err) { void err; }
        return serverData;
      }
      console.warn('[community] /api/posts returned', resp.status);
    } catch (e) {
      console.debug('[community] /api/posts fetch failed', e);
    }

    // Fallback: query Supabase directly (client-side) if API call failed
    try {
        const { data, error } = await supabase
          .from('posts')
          .select('id,title,content,author_display,created_at,likes')
          .order('created_at', { ascending: false })
          .limit(100);
      if (error) {
        console.error('loadPosts error', error);
  try { showToast('Êó†Ê≥ïÂä†ËΩΩÂ∏ñÂ≠êÔºö' + (error.message || JSON.stringify(error)), 'error', 8000); } catch (e) { void e; }
        return [];
      }
      return data || [];
    } catch (err) {
      console.error('loadPosts fallback error', err);
      return [];
    }
  }

  function createPostElement(p) {
    const li = document.createElement('li');
    li.className = 'thread-item p-4 rounded border hover:shadow-md transition';
    li.setAttribute('data-id', p.id);
    li.setAttribute('data-pubdate', p.created_at);
    li.setAttribute('data-likes', String(p.likes || 0));
  // store an author fallback: prefer author_display, then nav header display, then author_email local-part
  // we attempt to read the current header display if available (client-side render)
  let headerDisplay = '';
  try {
    const navEl = document && document.getElementById && document.getElementById('auth-status-header');
    if (navEl) {
      headerDisplay = (navEl.textContent || '').toString().trim();
      if (headerDisplay.toLowerCase().startsWith('hi,')) headerDisplay = headerDisplay.substring(3).trim();
    }
  } catch (e) { void e; }
  const authorFallback = p.author_display || headerDisplay || (p.author_email ? (String(p.author_email).split('@')[0]) : '') || '';
  li.setAttribute('data-author', authorFallback);
  // store full content for detail view
  li.setAttribute('data-content', p.content || '');

    const title = escapeHtml(p.title || 'Untitled');
    const content = escapeHtml(((p.content || '')).slice(0, 800));

    li.innerHTML = `
      <a href="#" class="block">
        <div class="flex justify-between">
          <div>
            <h4 class="font-semibold text-lg">${title}</h4>
            <p class="text-sm text-muted mt-1">Posted by <span class="font-semibold">${escapeHtml(authorFallback)}</span> ¬∑ <time class="text-xs text-muted">${new Date(p.created_at).toLocaleString()}</time></p>
            <p class="text-sm text-muted mt-2">${content}</p>
          </div>
          <div class="flex items-center space-x-4 text-sm text-muted">
            <button class="like-btn flex items-center space-x-1 text-muted" aria-label="like" data-id="${p.id}">
              <span aria-hidden="true" class="like-icon transition-transform duration-150">‚ô°</span>
              <span class="like-count font-medium">${p.likes || 0}</span>
            </button>
            <div class="flex items-center space-x-1">
              <span aria-hidden="true">üí¨</span>
              <span class="font-medium">0</span>
            </div>
            <button class="delete-post hidden text-sm text-red-600 hover:underline" data-id="${p.id}">Delete</button>
          </div>
        </div>
      </a>
    `;

  // set author id attribute if available
  li.setAttribute('data-author-id', p.author_id || '');

  // reveal delete button if current user is the author
  (async () => {
    try {
      const { data } = await supabase.auth.getUser();
      const user = data?.user ?? null;
      const deleteBtn = li.querySelector('.delete-post');
      if (!deleteBtn) return;

      // get post-side author info
      const authorId = (li.getAttribute('data-author-id') || '').trim();
      const authorDisplay = (li.getAttribute('data-author') || '').trim();
      const authorEmail = (p.author_email || '') + '';

      if (!user) return; // not logged in -> keep hidden

      // derive user identity values
      const userId = (user.id || '') + '';
      const userEmail = (user.email || '') + '';
      const userDisplayRaw = (user.user_metadata && (user.user_metadata.username || user.user_metadata.name || user.user_metadata.display_name)) || (userEmail ? userEmail.split('@')[0] : '');

      const norm = (s) => (s || '').toString().trim().toLowerCase();

      const matchById = authorId && userId && norm(authorId) === norm(userId);
      const matchByEmail = authorEmail && userEmail && norm(authorEmail) === norm(userEmail);
      const matchByDisplay = authorDisplay && userDisplayRaw && norm(authorDisplay) === norm(userDisplayRaw);

      if (matchById || matchByEmail || matchByDisplay) {
        deleteBtn.classList.remove('hidden');
        deleteBtn.onclick = async (ev) => {
          ev.preventDefault();
          if (!confirm('Delete this post?')) return;
          const tokenResp = await supabase.auth.getSession();
          const token = tokenResp?.data?.session?.access_token || null;
          const headers = { 'Content-Type': 'application/json' };
          if (token) headers.Authorization = `Bearer ${token}`;
          try {
            const resp = await fetch('/api/posts', { method: 'DELETE', headers, body: JSON.stringify({ id: p.id }) });
            if (!resp.ok) {
              const j = await resp.json().catch(()=>({}));
              return showToast('Failed to delete: ' + (j?.error || resp.statusText), 'error');
            }
            // remove element from DOM
            try { li.remove(); } catch (_) { void _; }
            showToast('Post deleted', 'success');
          } catch (e) {
            console.error('delete post error', e);
            showToast('Failed to delete', 'error');
          }
        };
      }
  } catch (e) { void e; }
  })();

    return li;
  }

  // Post detail modal (document root modal)
  const detailModalHtml = `
  <div id="post-detail-modal" class="hidden fixed inset-0 z-50">
    <div class="flex items-center justify-center min-h-screen p-4">
  <div id="pd-overlay" class="absolute inset-0 bg-black/50" aria-hidden="true"></div>
      <div class="relative bg-white dark:bg-slate-800 rounded shadow-lg w-full max-w-3xl p-6 z-10 max-h-[90vh] overflow-auto">
        <header class="flex items-start justify-between mb-4">
          <div class="flex items-center space-x-4">
            <h3 id="pd-title" class="text-xl font-semibold"></h3>
            <p id="pd-meta" class="text-sm text-muted"></p>
          </div>
          <div class="flex items-center space-x-2">
            <button id="pd-close" class="text-gray-500 dark:text-gray-300 hover:underline">Close</button>
          </div>
        </header>
        <!-- Post content: separated by top and bottom horizontal lines -->
        <div class="mt-3">
          <div class="border-t border-b border-gray-200 dark:border-slate-700 py-4">
            <article id="pd-content" class="prose max-w-none text-sm text-default"></article>
          </div>
        </div>
        <footer class="mt-4 text-sm text-muted">
          <div id="pd-stats" class="flex flex-col items-start space-y-2">
            <div class="flex items-center">
              <div class="w-8 flex justify-center">
                <button id="pd-like-btn" class="like-btn flex items-center justify-center w-8 h-8 rounded-full text-muted" aria-label="like" data-id="">
                  <span aria-hidden="true" class="like-icon transition-transform duration-150">‚ô°</span>
                </button>
              </div>
              <div id="pd-likes" class="text-sm text-muted">Liked: <span id="pd-like-count" class="like-count font-medium">0</span></div>
            </div>
            <div class="flex items-center">
              <div class="w-8 flex justify-center"><span aria-hidden="true">üí¨</span></div>
              <div id="pd-comments" class="text-sm text-muted">Comments: <span id="pd-comments-count">0</span></div>
            </div>
          </div>

          <!-- Comments list -->
          <div id="pd-comments-container" class="mt-3">
            <ul id="pd-comments-list" class="space-y-2 max-h-48 overflow-auto text-sm text-default mb-3"></ul>

            <!-- Pager: show current/last with left/right chevrons -->
            <div id="pd-comments-pager" class="flex items-center justify-center text-sm text-muted mb-2 space-x-4">
              <button id="pd-comments-left" class="px-2 py-1 rounded border" aria-label="Previous page">‚Äπ</button>
              <div id="pd-comments-page-display" class="font-medium">1/1</div>
              <button id="pd-comments-right" class="px-2 py-1 rounded border" aria-label="Next page">‚Ä∫</button>
            </div>

            <!-- Add comment form -->
            <div class="mt-2">
              <label for="pd-comment-input" class="sr-only">Add a comment</label>
              <textarea id="pd-comment-input" rows="3" class="w-full rounded border px-3 py-2 text-sm" placeholder="Write a comment..."></textarea>
              <div class="flex justify-end mt-2">
                <button id="pd-comment-submit" class="px-3 py-1 rounded bg-[#006994] text-white text-sm">Comment</button>
              </div>
            </div>
          </div>
        </footer>
      </div>
    </div>
  </div>`;

  // append modal to document body once DOM is ready (robust: append immediately if DOM already ready)
  function ensureDetailModal() {
    try {
      if (!document.getElementById('post-detail-modal')) {
        const frag = document.createElement('div');
        frag.innerHTML = detailModalHtml;
        document.body.appendChild(frag.firstElementChild);
      }
  } catch (e) { void e; }
  }
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', ensureDetailModal);
  } else {
    ensureDetailModal();
  }

  function showPostDetailByElement(li) {
    const id = li.getAttribute('data-id');
    const title = li.querySelector('h4')?.textContent || '';
    let author = (li.getAttribute('data-author') || '').trim();
    // try visible element fallback: prefer the author span in the list (p span.font-semibold),
    // then any .font-semibold, then fall back to .font-medium (comment count markers)
    if (!author) {
      const vis = li.querySelector('p span.font-semibold') || li.querySelector('.font-semibold') || li.querySelector('.font-medium');
      author = vis ? (vis.textContent || '').trim() : '';
    }
    // treat common placeholders as missing so we can fallback to navName
    const isPlaceholderAuthor = (() => {
      const raw = (author || '').toString().trim();
      if (!raw) return true;
      const low = raw.toLowerCase();
      if (['ÂåøÂêç', 'anonymous', 'anon'].includes(low)) return true;
      try {
        if (/^\d+ÁöÑ\d+$/.test(raw)) return true; // matches patterns like "1ÁöÑ1"
  } catch (e) { void e; }
      return false;
    })();

    if (isPlaceholderAuthor) {
      const navEl = document.getElementById('auth-status-header');
      if (navEl) {
        let navName = (navEl.textContent || '').trim();
        if (navName.toLowerCase().startsWith('hi,')) navName = navName.substring(3).trim();
        author = navName || author || '';
      }
    }
    // prefer stored data-content, fallback to visible snippet in the list
    const content = li.getAttribute('data-content') || li.querySelector('p.text-sm')?.textContent || li.querySelector('p')?.textContent || '';
    const likes = li.getAttribute('data-likes') || '0';
    const pub = li.getAttribute('data-pubdate') || '';

    const modal = document.getElementById('post-detail-modal');
    if (!modal) return;
    modal.classList.remove('hidden');
  const t = document.getElementById('pd-title'); if (t) t.textContent = title;
  const m = document.getElementById('pd-meta'); if (m) m.innerHTML = `Posted by <span class="font-semibold">${escapeHtml(author)}</span> ¬∑ <time class="text-xs text-muted">${new Date(pub).toLocaleString()}</time>`;
    const c = document.getElementById('pd-content'); if (c) c.textContent = content;
  const likeBtn = document.getElementById('pd-like-btn');
  if (likeBtn) {
    likeBtn.setAttribute('data-id', id || '');
    const icon = likeBtn.querySelector('.like-icon');
    const countEl = document.getElementById('pd-like-count');
    if (countEl) countEl.textContent = String(likes || '0');
    try {
      const liked = getLikedSet();
      if (icon) {
        if (liked.has(id)) {
          icon.textContent = '‚ù§';
          icon.classList.add('text-red-500');
        } else {
          icon.textContent = '‚ô°';
          icon.classList.remove('text-red-500');
        }
      }
  } catch { /* noop */ }
  }
  // comments placeholder: update count and render stored comments
  const cmCount = document.getElementById('pd-comments-count'); if (cmCount) cmCount.textContent = (li.querySelector('.font-medium') ? li.querySelector('.font-medium').textContent : '0');
    renderCommentsForPost(id);

  const closeBtn = document.getElementById('pd-close'); if (closeBtn) closeBtn.onclick = (e) => { e.preventDefault(); modal.classList.add('hidden'); };
  // clicking outside the modal (overlay) should also close the modal
  const overlay = document.getElementById('pd-overlay'); if (overlay) overlay.onclick = (e) => { e.preventDefault(); modal.classList.add('hidden'); };

    // wire comment submit
    const submitBtn = document.getElementById('pd-comment-submit');
    const textArea = document.getElementById('pd-comment-input');
    if (submitBtn && textArea) {
      submitBtn.onclick = async (ev) => {
        ev.preventDefault();
        const text = textArea.value ? textArea.value.trim() : '';
  if (!text) return showToast('Comment cannot be empty', 'error');
        const { data } = await supabase.auth.getUser();
        const user = data?.user ?? null;
            if (!user) { showToast('Please log in', 'error'); openAuthPanel(); return; }

        // post to server
        const res = await postCommentToServer(id, text);
        if (res && res.error) {
          showToast('Comment posting failedÔºö' + (res.error || ''), 'error');
          return;
        }

        // refresh comments (go to first page to show newest)
        await renderCommentsForPost(id, 1);
        textArea.value = '';

        // update thread list comment count visual by fetching total from server
        try {
          const meta = await fetch(`/api/comments?postId=${encodeURIComponent(id)}&page=1&limit=1`);
          if (meta.ok) {
            const mj = await meta.json();
            const total = mj.total || 0;
            const fonts = li.querySelectorAll('.font-medium');
            if (fonts && fonts.length) {
              const last = fonts[fonts.length - 1];
              last.textContent = String(total);
            }
          }
  } catch (e) { void e; }
      };
    }
  }

  // Ensure comment input reflects login state (disable and show login CTA when not logged in)
  try {
    const { data: _u } = await supabase.auth.getUser();
    const isUser = !!(_u?.user);
    const pdText = document.getElementById('pd-comment-input');
    const pdSubmit = document.getElementById('pd-comment-submit');
    if (pdText && pdSubmit) {
      if (!isUser) {
        pdText.setAttribute('disabled', 'true');
        pdText.placeholder = 'Please log in to comment';
        pdSubmit.textContent = 'Login to comment';
        pdSubmit.onclick = (e) => { e.preventDefault(); openAuthPanel(); };
      } else {
        pdText.removeAttribute('disabled');
        pdText.placeholder = 'Write a comment...';
        pdSubmit.textContent = 'Comment';
        // rebind original handler by re-calling renderCommentsForPost when opened if needed
      }
    }
  } catch { /* noop */ }

  // double-click handler: expand post instead of logging out
  // Support both single-click and double-click to open post detail.
  // Use a small timeout to distinguish single vs double clicks and avoid double-opens.
  let __clickOpenTimer = null;
  let __suppressNextClick = false;

  document.body.addEventListener('click', (ev) => {
    try {
      const li = ev.target && ev.target.closest && ev.target.closest('.thread-item');
      if (!li) return;
      console.debug('[community] thread click detected', { id: li.getAttribute('data-id') });
      ev.preventDefault();
      // if a dblclick just happened, skip this click
      if (__suppressNextClick) { __suppressNextClick = false; return; }
      if (__clickOpenTimer) clearTimeout(__clickOpenTimer);
      __clickOpenTimer = setTimeout(() => {
        showPostDetailByElement(li);
        __clickOpenTimer = null;
      }, 200);
  } catch (err) { void err; }
  });

  document.body.addEventListener('dblclick', (ev) => {
    try {
      const li = ev.target && ev.target.closest && ev.target.closest('.thread-item');
      if (!li) return;
      console.debug('[community] thread dblclick detected', { id: li.getAttribute('data-id') });
      // cancel pending single-click open
      if (__clickOpenTimer) { clearTimeout(__clickOpenTimer); __clickOpenTimer = null; }
      __suppressNextClick = true;
      ev.preventDefault();
      ev.stopPropagation();
      showPostDetailByElement(li);
  } catch (err) { void err; }
  });

  async function refreshPostList() {
    const list = $('thread-list');
    if (!list) return;
      list.innerHTML = ''; 
      console.log('[community] refreshPostList: loading posts');
            let posts = await loadPosts();
            // Ensure locally pending posts are preserved and shown at top even if server/API fails
            try {
              const pending = getPendingPosts();
              if (Array.isArray(pending) && pending.length) {
                // prepend any pending posts that are not already in posts (match by id or title+content)
                const merged = [];
                for (const p of pending) {
                  const exists = posts.some(s => (s.id && p.id && String(s.id) === String(p.id)) || (s.title === p.title && (s.content||'').slice(0,200) === (p.content||'').slice(0,200)));
                  if (!exists) merged.push(p);
                }
                posts = merged.concat(posts || []);
              }
            } catch (e) { void e; }
    posts.forEach((p) => {
      const el = createPostElement(p);
      list.appendChild(el);
    });
            console.log('[community] refreshPostList: rendered posts in DOM', { rendered: list.children.length });
    updateLikeButtons();
    // asynchronously fetch current comment totals for each post so the thread list shows up-to-date counts
    try {
      posts.forEach(async (p) => {
        try {
          const resp = await fetch(`/api/comments?postId=${encodeURIComponent(p.id)}&page=1&limit=1`);
          if (!resp.ok) return;
          const j = await resp.json().catch(() => ({}));
          const total = j.total || 0;
          const li = document.querySelector(`.thread-item[data-id="${p.id}"]`);
          if (li) {
            const fonts = li.querySelectorAll('.font-medium');
            if (fonts && fonts.length) {
              const last = fonts[fonts.length - 1];
              last.textContent = String(total);
            }
            li.setAttribute('data-comments', String(total));
          }
  } catch (e) { void e; }
      });
  } catch (e) { void e; }
  }

  // Likes: try to persist to Supabase (requires RLS to allow authenticated updates), fallback to client-only
  function getLikedSet() {
    const raw = localStorage.getItem('bb_likes');
    try { return new Set(raw ? JSON.parse(raw) : []); } catch { return new Set(); }
  }
  function saveLikedSet(set) { localStorage.setItem('bb_likes', JSON.stringify(Array.from(set))); }

  async function toggleLike(id) {
    const li = document.querySelector(`.thread-item[data-id="${id}"]`);
    if (!li) return;
    const liked = getLikedSet();
    let count = Number(li.getAttribute('data-likes') || '0');
    if (liked.has(id)) {
      liked.delete(id); count = Math.max(0, count - 1);
    } else {
      liked.add(id); count = count + 1;
    }
    li.setAttribute('data-likes', String(count));
    const countEl = li.querySelector('.like-count'); if (countEl) countEl.textContent = String(count);
    saveLikedSet(liked);
    // persist liked set then reconcile all like buttons (list + modal)
    updateLikeButtons();

    // also update modal like count/icon if open
    try {
      const pdCount = document.getElementById('pd-like-count');
      const pdBtn = document.getElementById('pd-like-btn');
      const pdIcon = pdBtn ? pdBtn.querySelector('.like-icon') : null;
      if (pdCount) pdCount.textContent = String(li.getAttribute('data-likes') || '0');
      if (pdIcon) {
        if (getLikedSet().has(id)) {
          pdIcon.textContent = '‚ù§';
          pdIcon.classList.add('text-red-500');
          pdIcon.classList.add('scale-110');
          setTimeout(() => { try { pdIcon.classList.remove('scale-110'); } catch { /* noop */ } }, 260);
        } else {
          pdIcon.textContent = '‚ô°';
          pdIcon.classList.remove('text-red-500');
        }
      }
  } catch { /* noop */ }

    // optimistic: try to update in DB via server API (which will fall back to file if needed)
    try {
      // include user's access token so server can verify identity
      const { data: _sess } = await supabase.auth.getSession();
      const token = _sess?.session?.access_token || null;
      const headers = { 'Content-Type': 'application/json' };
      if (token) headers.Authorization = `Bearer ${token}`;
      await fetch('/api/posts', {
        method: 'PATCH',
        headers,
        body: JSON.stringify({ id, likes: count }),
      });
    } catch (e) {
      // ignore DB errors for now
      console.debug('like update failed', e);
    }
  }

  function updateLikeButtons() {
    const liked = getLikedSet();
    document.querySelectorAll('.like-btn').forEach((btn) => {
      const id = btn.getAttribute('data-id');
      const li = document.querySelector(`.thread-item[data-id="${id}"]`);
      const countEl = btn.querySelector('.like-count');
      const icon = btn.querySelector('.like-icon');
      if (!li || !countEl || !icon) return;
      const likes = li.getAttribute('data-likes') || '0';
      countEl.textContent = likes;
      if (liked.has(id)) {
        // liked: filled red heart
        icon.textContent = '‚ù§';
        icon.classList.add('text-red-500');
      } else {
        // not liked: outline heart
        icon.textContent = '‚ô°';
        icon.classList.remove('text-red-500');
      }
    });
  }

  // Wire UI
  async function initCommunityUI() {
    // If user landed here via Supabase magic link, the auth tokens may be in the URL fragment (#access_token=...)
    // Try to extract and set the session so clicking the email link immediately signs the user in.
    try {
      if (typeof window !== 'undefined' && window.location && window.location.hash) {
        const hash = window.location.hash.substring(1);
        if (hash && hash.includes('access_token')) {
          try {
            const params = new URLSearchParams(hash);
            const access_token = params.get('access_token');
            const refresh_token = params.get('refresh_token');
            const tokenType = params.get('type');
            console.debug('[community] detected auth fragment', { tokenType });
      if (access_token) {
              // set session in supabase client (v2 API)
              try {
                await supabase.auth.setSession({ access_token, refresh_token });
                // remove tokens from URL to avoid leaking in referrers
                try { history.replaceState(null, '', window.location.pathname + window.location.search); } catch { /* noop */ }
                // If this is a recovery (password reset) link, prompt user to set a new password
                if (tokenType === 'recovery') {
                  // quick prompt fallback: ask for new password and update user
                  try {
                    const newPwd = window.prompt('Please enter a new password (at least 6 characters) to complete password reset:');
                    if (newPwd && newPwd.length >= 6) {
                      const upd = await supabase.auth.updateUser({ password: newPwd });
                      if (upd.error) {
                        console.warn('[community] updateUser failed', upd.error);
                        showToast('Failed to set new password: ' + (upd.error.message || String(upd.error)), 'error');
                      } else {
                        showToast('Password has been reset and you are logged in', 'success');
                      }
                    } else {
                      showToast('No new password set; if needed, request a password reset email', 'warn');
                    }
                  } catch (e) {
                    console.error('[community] recovery flow failed', e);
                    showToast('Password reset failed, please try again', 'error');
                  }
                } else {
                  showToast('Verification successful, you are logged in', 'success');
                }
              } catch (e) {
                console.warn('[community] supabase.auth.setSession failed', e);
                showToast('Verification failed or the link has expired. Please try again or resend the verification email.', 'error');
              }
            }
          } catch (err) { console.error('failed to parse auth fragment', err); }
        }
      }
    } catch (err) { console.error('auth fragment handling error', err); }

    await initAuth();
    await refreshPostList();

    // --- Robust binding: attach listeners directly and log actions ---
    const openRegisterBtn = document.getElementById('open-register-panel');
    const openLoginBtn = document.getElementById('open-login-panel');
    const closeAuthBtn = document.getElementById('close-auth-panel');
    const headerRegisterForm = document.getElementById('header-registerForm');
    const headerLoginForm = document.getElementById('header-loginForm');

    console.log('[community] binding header auth elements', { openRegisterBtn: !!openRegisterBtn, openLoginBtn: !!openLoginBtn, headerRegisterForm: !!headerRegisterForm, headerLoginForm: !!headerLoginForm });

    if (openRegisterBtn) {
      openRegisterBtn.addEventListener('click', (e) => {
        e.preventDefault();
        console.log('[community] open-register clicked');
        $('auth-panel')?.classList.remove('hidden');
        headerRegisterForm?.classList.remove('hidden');
        headerLoginForm?.classList.add('hidden');
        $('h-reg-email')?.focus();
      });
    }
    if (openLoginBtn) {
      openLoginBtn.addEventListener('click', (e) => {
        e.preventDefault();
        console.log('[community] open-login clicked');
        $('auth-panel')?.classList.remove('hidden');
        headerLoginForm?.classList.remove('hidden');
        headerRegisterForm?.classList.add('hidden');
        $('h-login-email')?.focus();
      });
    }
    if (closeAuthBtn) {
      closeAuthBtn.addEventListener('click', (e) => {
        e.preventDefault();
        console.log('[community] close-auth clicked');
        $('auth-panel')?.classList.add('hidden');
      });
    }

    if (headerRegisterForm) {
      headerRegisterForm.addEventListener('submit', (e) => { console.log('[community] header-registerForm submit'); return handleHeaderRegister(e); });
    }
    if (headerLoginForm) {
      headerLoginForm.addEventListener('submit', (e) => { console.log('[community] header-loginForm submit'); return handleHeaderLogin(e); });
    }

    // like button delegation ‚Äî require login before liking
    document.body.addEventListener('click', async (e) => {
      try {
        const btn = e.target.closest && e.target.closest('.like-btn');
        if (!btn) return;
        e.preventDefault();
        // ensure logged in (use cached CURRENT_USER to avoid an auth round-trip)
  if (!CURRENT_USER) { showToast('Please log in to like posts', 'error'); openAuthPanel(); return; }
        await toggleLike(btn.getAttribute('data-id'));
      } catch (err) {
        console.error('[community] like delegation error', err);
      }
    });

    // tabs ‚Äî use event delegation on the container for more reliable handling
    const tabsContainer = document.getElementById('community-tabs');
    if (tabsContainer) {
      tabsContainer.addEventListener('click', (ev) => {
        try {
          console.log('[community] tabsContainer click', { target: ev.target && ev.target.tagName, html: ev.target && ev.target.outerHTML && ev.target.outerHTML.slice(0,200) });
          const btn = ev.target && ev.target.closest && ev.target.closest('.tab-btn');
          if (!btn) { console.log('[community] tabsContainer click: no .tab-btn on target'); return; }
          ev.preventDefault();
          const mode = btn.getAttribute('data-mode');
          console.log('[community] tab clicked', { mode });
          document.querySelectorAll('#community-tabs .tab-btn').forEach((x) => x.classList.remove('bg-[#006994]', 'text-white'));
          btn.classList.add('bg-[#006994]', 'text-white');

          // basic client-side filtering for my-posts / my-liked
          const list = $('thread-list');
          if (!list) return;

          // reset display for all items before applying a mode (prevents leftover 'display: none')
          Array.from(list.children).forEach((li) => { li.style.display = ''; });

          if (mode === 'my-posts') {
            supabase.auth.getUser().then(({ data }) => {
              const user = data?.user ?? null;
              if (!list) return;
              const myDisplay = user ? ((user.user_metadata && (user.user_metadata.username || user.user_metadata.name)) || ((user.email||'').split('@')[0])) : null;
              Array.from(list.children).forEach((li) => {
                const author = (li.getAttribute('data-author') || '').toLowerCase();
                const my = myDisplay ? (String(myDisplay).toLowerCase() === author) : false;
                li.style.display = my ? '' : 'none';
              });
            });
          } else if (mode === 'my-liked') {
            const liked = getLikedSet();
            Array.from(list.children).forEach((li) => { li.style.display = liked.has(li.getAttribute('data-id')) ? '' : 'none'; });
          } else if (mode === 'most-liked') {
            // ensure all items visible before sorting
            Array.from(list.children).forEach((li) => { li.style.display = ''; });
            Array.from(list.children).sort((a,b)=>Number(b.getAttribute('data-likes'))-Number(a.getAttribute('data-likes'))).forEach(n=>list.appendChild(n));
          } else { // latest
            refreshPostList();
          }
        } catch (err) {
          console.error('[community] tab click handler error', err);
        }
      });
    }

    // New topic button
    $('open-new-topic')?.addEventListener('click', async (e) => {
      e.preventDefault();
      try {
        const { data } = await supabase.auth.getUser();
        const user = data?.user ?? null;
        // If supabase didn't return a user, check header DOM for an authenticated display
        const headerStatus = document.getElementById('auth-status-header');
        const headerHasUser = headerStatus && (headerStatus.textContent || '').trim();
        if (!user && !headerHasUser) showToast('Please log in to post (you can still view this dialog)', 'warn');
      } catch { /* noop */ }
      $('new-topic-modal')?.classList.remove('hidden'); $('new-topic-title')?.focus();
    });

    $('cancel-new-topic')?.addEventListener('click', (e) => { e.preventDefault(); $('new-topic-modal')?.classList.add('hidden'); });

    // show supabase configuration warning early if env vars not present at build time
    try {
      const isSupabaseConfigured = Boolean(import.meta.env.PUBLIC_SUPABASE_URL && import.meta.env.PUBLIC_SUPABASE_ANON_KEY);
      if (!isSupabaseConfigured) {
        $('supabase-warning')?.classList.remove('hidden');
      }
    } catch {
      // import.meta may not be reachable in some contexts; ignore
    }

    $('new-topic-form')?.addEventListener('submit', async (e) => {
      e.preventDefault();
      const titleEl = $('new-topic-title');
      const contentEl = $('new-topic-content');
      const submitBtn = (e.target && e.target.querySelector && e.target.querySelector('button[type="submit"]')) || null;

      const title = titleEl?.value?.trim();
      const content = contentEl?.value?.trim();

  // client-side validation
  if (!title) return showToast('Please provide a title.', 'error');
  if (title.length > 200) return showToast('The title length must not exceed 200 characters.', 'error');
  if (!content || content.length < 10) return showToast('Content is too short. At least 10 characters.', 'error');
  if (content.length > 10000) return showToast('Content is too long. Please limit it to 10,000 characters.', 'error');

      const { data } = await supabase.auth.getUser();
      const user = data?.user ?? null;
    if (!user) return showToast('please log in first!', 'error');

  const display = (user.user_metadata && (user.user_metadata.username || user.user_metadata.name)) || ((user.email||'').split('@')[0]);
  const payload = { title, content, author_display: display, likes: 0 };
      console.log('[community] creating post', { payload, user });

      // disable UI while submitting
      if (submitBtn) {
        submitBtn.disabled = true;
        submitBtn.setAttribute('aria-busy', 'true');
        submitBtn.dataset.origText = submitBtn.textContent;
        submitBtn.textContent = 'Posting...';
      }

      try {
        // Try server-side proxy first (requires SUPABASE_SERVICE_ROLE_KEY configured on server)
        let created = null;
        try {
          // include user's access token so server can verify identity
          const { data: _sess } = await supabase.auth.getSession();
          const token = _sess?.session?.access_token || null;
          const headers = { 'Content-Type': 'application/json' };
          if (token) headers.Authorization = `Bearer ${token}`;
          const resp = await fetch('/api/posts', {
            method: 'POST',
            headers,
            body: JSON.stringify(payload),
          });
          if (resp.ok) {
            const json = await resp.json();
            created = Array.isArray(json.data) ? json.data[0] : json.data;
          } else {
            // server-side proxy not available or returned error -> fallback to client
            const txt = await resp.text();
            console.warn('[community] server /api/posts returned', resp.status, txt);
          }
        } catch (e) {
          console.warn('[community] failed to call /api/posts, falling back to client supabase', e);
        }

        if (!created) {
          // fallback: attempt client-side insert
          try {
            const res = await supabase.from('posts').insert([payload]).select('*');
            console.log('[community] supabase insert response (client)', res);
            if (!res.error && res.data) {
              created = Array.isArray(res.data) ? res.data[0] : res.data;
            }
          } catch (e) {
            console.warn('[community] client-side insert failed', e);
          }
        }

        // If still not created (both server and client failed), create a local pending post
        if (!created) {
          const temp = Object.assign({}, payload);
          temp.id = 'local-' + Date.now().toString(36);
          temp.created_at = new Date().toISOString();
          // ensure author_display exists
          temp.author_display = temp.author_display || (display || 'You');
          try { addPendingPost(temp); } catch (e) { void e; }
          // insert optimistically so user sees their post immediately
          try {
            const list = document.getElementById('thread-list');
            if (list) {
              const existing = document.querySelector(`.thread-item[data-id="${temp.id}"]`);
              if (!existing) {
                const el = createPostElement(temp);
                list.insertBefore(el, list.firstChild);
                updateLikeButtons();
                el.classList.add('ring-2', 'ring-[#006994]');
                setTimeout(() => el.classList.remove('ring-2', 'ring-[#006994]'), 4000);
                try { el.scrollIntoView({ behavior: 'smooth', block: 'center' }); } catch (e) { void e; }
              }
            }
          } catch (e) { console.warn('[community] optimistic local insert failed', e); }
          showToast('Post saved locally and will sync when possible', 'success');
        }

  // success: optimistically insert the created row into the list so users see it immediately
        // then refresh from server shortly after to reconcile authoritative data
        try {
          if (created) {
            // ensure minimal fields exist
            if (!created.id) created.id = 'local-' + Date.now().toString(36);
            if (!created.created_at) created.created_at = new Date().toISOString();
            // mark as pending until server confirms with a real id
            if (!String(created.id).startsWith('local-')) {
              // server returned real id -> remove any matching pending entries
              try { removePendingMatching(created); } catch (e) { void e; }
            } else {
              try { addPendingPost(created); } catch (e) { void e; }
            }
            const list = document.getElementById('thread-list');
            if (list) {
              const existing = document.querySelector(`.thread-item[data-id="${created.id}"]`);
              if (!existing) {
                const el = createPostElement(created);
                list.insertBefore(el, list.firstChild);
                updateLikeButtons();
                // highlight & scroll into view
                el.classList.add('ring-2', 'ring-[#006994]');
                setTimeout(() => el.classList.remove('ring-2', 'ring-[#006994]'), 4000);
                try { el.scrollIntoView({ behavior: 'smooth', block: 'center' }); } catch (e) { void e; }
              }
            }
          }
        } catch (e) {
          console.warn('[community] optimistic insert failed', e);
        }

        // close modal and clear form
        $('new-topic-modal')?.classList.add('hidden');
        if (titleEl) titleEl.value = '';
        if (contentEl) contentEl.value = '';

        // schedule a full refresh to reconcile with server data
        setTimeout(() => refreshPostList(), 800);
      } catch (err) {
        console.error('[community] create post error', err);
    showToast('An error occurred while creating the post. Check the console for more information', 'error');
      } finally {
        if (submitBtn) {
          submitBtn.disabled = false;
          submitBtn.removeAttribute('aria-busy');
          submitBtn.textContent = submitBtn.dataset.origText || 'Post';
          delete submitBtn.dataset.origText;
        }
      }
    });
  }
  // If DOMContentLoaded already fired, call immediately; otherwise wait for the event
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initCommunityUI);
  } else {
    // DOM is already ready
    initCommunityUI();
  }
</script>
